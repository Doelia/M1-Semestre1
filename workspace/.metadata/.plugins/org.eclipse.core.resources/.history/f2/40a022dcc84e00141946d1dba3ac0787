import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.TreeSet;

public class Solver {

	public CSP problem; // l'instance de CSP
	private HashMap<String, Object> assignation; // codage d'une solution
													// partielle ou totale

	public Solver(CSP p) {
		problem = p;
		assignation = new HashMap<String, Object>();
	}

	// retourne une solution s'il en existe une, null sinon
	public HashMap<String, Object> searchSolution() {
		// TO DO : appel de backtrack
		return null;
	}
	
	private boolean contrainteEstVerifiee(String var, Constraint c) {
		
		Object valueVar = this.assignation.get(var);
		
		int iVar = 0;
		for (int i = 0; i < c.getArity(); i++) {
			if (c.getVariables().get(i).equals(var)) {
				iVar = i;
			}
		}
		
		for (ArrayList<Object> list : c.getValTuples()) { // Pour chaque tuple, [2, tutu]
			if (valueVar.equals(list.get(iVar))) { // Si la variable traitée est égale 
				for (int j = 0; j < list.size(); j++) {
					Object valueOfVar = this.assignation.get(c.getVariables().get(j));
					if (valueOfVar.equals(list.get(j)));
				}
			}
		}
	}

	// l'algo r�cursif
	private HashMap<String, Object> backtrack() {
		
		if (this.assignation.size() == this.problem.getVarNumber()) {
			return this.assignation;
		}
		
		// On choisit une variable non affectuée
		String chosenVar = this.chooseVar(this.problem.getVars(), this.assignation.keySet());
		
		for (Object val : this.tri(this.problem.getDom(chosenVar))) {
			this.assignation.put(chosenVar, val);
			if (true) { // Si consistant
				if (backtrack().size() == this.problem.getVarNumber()) {
					return this.assignation;
				}
			} else {
				this.assignation.remove(chosenVar);
			}
		}
		
		// On l'affecte
		if (true) { // si les contraintes sont respectées
			backtrack();
		} else {
			
		}
		return null;
	}

	// choix d'une variable
	private String chooseVar(Set<String> allVar, Set<String> assignedVar) {
		for (String v : allVar) {
			if (!assignedVar.contains(v)) {
				return v;
			}
		}
		return null;
	}

	private TreeSet<Object> tri(TreeSet<Object> values) {
		return values;
	}

	// retourne l'ensemble des solutions
	public HashSet<HashMap<String, Object>> searchAllSolutions() {
		// TO DO
		return null;
	}
}
